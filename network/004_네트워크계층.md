  
*데스크탑 입장에서는 여러 응용프로그램들이 돌아가고 있어서 소켓은 여러개고 그러면 조각화된 송수신 패킷들도 많을텐데 컴퓨터의 네트워크 계층에서는 받은 패킷들을 합칠 때 같은 포트들의 패킷들끼리 뭉쳐야 할텐데 이걸어떻게 구분해서 합칠까?*   
*> 추측 컴퓨터에는 임시 저장소인 레지스터들이 많고 이 레지스터들은 역할이 딱 정해져 있지 않고 동적으로 변한다. 따라서 첫번째 패킷이 왔을 때 이것을 저장할 장소를 정하고 그 패킷과 같이 원래 데이터 크기가 타고 처음 패킷 번호 다음 번호일때 해당 저장소에 넣고 다 오면 거기서 합체시키고 해당 메모리를 지정을 해제 시킬 것 같다*    
*그러면 데이터의 세부구성은 다른데 크기가 같다면 데이터 조합이 잘못될 수 있을텐데 이것을 어떻게 막을까?*   

## 네트워크 계층   
+ 네트워크 계의 기능은 총 2개로 나눌 수 있다(라우터 관점)   
  + 포워딩 :
    패킷이 출발지에서 송신돼 인접한 라우터로 보내지고, 여러 라우터를 거쳐 목적지에 도달하는 것(출발지와 목적지 관점   
  + 라우팅 :
    패킷을 경로상의 다음 네트워크 장치로 전달하고 목적지까지의 경로를 결정하는 기능을 제공한다(경로 관점)

+ 다르게 2개로 나룰 수 있다(네트워크 자체 관점)   
  + 포워딩 평면 :
    어느 패킷이 라우터의 입력 인터페이스에 도착하면 출력 인터페이스 중 하나의 혹은 여러개를 선택해 패킷을 전달하는 방식()
  + 제어 평면 :
    패킷이 출발지에서 목적지까지 전달되기 위한 경로를 결정하는 방식

+ 네트워크 계층 IP는 비신뢰성과 비연결형이 특징이다
  + 비신뢰성 :
    보내는 것만 열심히 하고 순서대로 안전하게 보냈다는 보장안함
  + 비연결형 :
    도착지까지 가는 경로가 일정하지 않음
### IPv4   
***헤더 구성**     
+ 버전 (4비트) | 헤더 길이 (4비트) | 서비스 품질 유형(6비트) | ECN(2비트) | 패킷길이(16비트)
+ 조각낸 애들 뭉치기 판별 식별자(16비트) | 조각화 된것인지 판별 플래그(3비트) | 전체 데이터가 얼마인지 알려주는 것 단편 오프셋(13비트)
+ 유지시간(8비트) | 프로토콜(8비트) | 헤더 체크섬(16비트)
+ 출발지(32비트)
+ 도착지(32비트)
+ 옵션

### IPv6   
IPv4보다 더 큰 주소 공간을 가지나 구조가 더 간결하다      
**헤더 구조**   
+ 버전(4비트) | 서비스 품질 유형 (6비트) | ECN(2비트) | 흐름 라벨(20비트)
+ 페이로드 길이(16비트) | 다음 헤더(8비트) | ipv4 유지시간 홉 제한(8)
+ 출발지 (128비트)
+ 도착지 (128비트)

### 터널링
: IPv4 인프라 시스템에서도 ipv6 시스템과 통신할 수 있게하는 방법   
+ 인프라 시스템의 시작점인 ipv6라우터가 받은 데이터그램을 패킷으로 만들지 않고 ipv4 필드로 데이터그램을 옮기는 캡슐화를 진행한다
+ 끝지점은 다시 하위호환성 덕에 ipv6로 다시 바꾼다

### 브로드캐스트   
: 같은 네트워크에 있는 노드 전체에 파일을 전송하는 것   
+ 출발지 브로드 캐스트
  : 출발지에서 복제해서 보내는 것 송신자가 참여자의 주소를 다 알아야해서 전송이 지연될 수 있다
+ 네트워크 브로드캐스트
  : 바로 인접한 라우터로 보내는 걸로 복제한다. 속도가 빠른 편
